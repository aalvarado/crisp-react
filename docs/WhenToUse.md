## When To Use
On contrary to the title of the section, let’s start with “When not to use it”:

* You are looking for run-time SSR because the content of your landing page changes frequently throughout the day. For example, an e-commerce shop needs to show constantly changing specials. Or the landing page should reflect user's purchasing history. In such a case this solution would be suboptimal, it implements build-time SSR also known as prerendering or static generation.

    > The scenario described above would be best served by one of the run-time SSR frameworks. The sole reason for that is the landing page performance. If prerendered into HTML at build-time, the landing page would need two downloads done sequentially: download the page first and then fetch data to incorporate it into HTML. Run-time SSR allows to fetch data and generate final HTML at the server, then send it to the client so that only one download is required.<br/><br/>This benefit evaporates for internal SPA pages provided the code is reasonably written (e.g. no huge tables are rendered without pagination, virtual scrollable views etc.) since in most cases the data is more concise than its HTML markup and can be downloaded quicker. Also SPA facilitates nearly instantaneous page switch and can use dimming, display a spinner/progress bar or use other means to manage user's expectations related to the data fetching delay. Managing user expectations during the entire page loading delay (due to network trips introduced by SSR) could be more challenging.<br/><br/>It's worth noting that even though complete page rendering performed by a single server thread is likely to be faster than DOM alteration performed by SPA thread, the difference won't be drastic due to both threads running on a single digit GHz CPU.

* Your React/NodeJS/TypeScript knowledge corresponds to a novice level. On the other hand, you don’t need to be an expert in any of those fields in order to use Crisp React.

Now we can switch back to "When to use".<br/>
Crisp React can help to achieve top security and performance along with simplicity and maintainability. It makes most sense when you strive to develop a project tailored specifically to your needs and consider frameworks with lots of pre-baked functionality to be a liability rather than an advantage. This approach assumes you want to choose third-party libraries/packages as to not reinvent the wheel and write the code utilising those to avoid (or keep at the bare minimum) the lowest-common-denominator implementation meant to suit everyone.

This solution would be beneficial if one or more of the cases described below apply to your situation. The title of each case describes a concern or need you might have.
### Case: Performance
The angle you are coming from.<br/>
You understand that performance affects SEO and user satisfaction. You are aware of Google mobile-first indexing approach and estimations linking page loading delays to the percentage of users who abandon websites. You know that Google has currently selected Moto G4 as a typical (and far from top range) device to measure website performance in its online [benchmarking tool](https://web.dev/measure/). Which emulates 3G for speed tests because lots of people live outside 4G/5G coverage area.

The concerns.<br/>
You have excluded run-time SSR due to its underlying complexity and fairly static nature of your website's landing page. You are concerned about both SPA loading performance and the approach to prerendering taken by opinionated SSR frameworks. With respect to SPA, you know that its script bundle needs to be downloaded, parsed and executed for the DOM to be created. It makes the landing page of SPA visible after a delay. On the other hand, prerendering of all web pages routinely performed by opinionated SSR frameworks necessitates network trips for each and every page to fetch HTML from the server. Which results in delays for all pages, not only for the landing one.

The SPA consideration.<br/>
Regarding SPA loading performance, you are satisfied with Crisp React ability to prerender the SPA landing page and split a monolithic webapp into multiple SPAs each rendered by its own and smaller bundle that can be downloaded faster. You have tested the transitions between internal SPA pages for your website in the Moto G4 scenario using Chrome DevTools and concluded that the transitions (effected by the script bundle altering the DOM) appear to be instantaneous to users.

The SSR consideration.<br/>
As for SSR frameworks and the HTML fetching delay for all pages, you know that the delay for each network trip has 2 components: the server delay to respond (called [TTFB](https://developers.google.com/web/tools/chrome-user-experience-report/#time-to-first-byte)) and the download time. You know that TTFB varies, ranges in the best case from tens to hundred of milliseconds and depends on the proximity to the nearest CDN datacenter among other factors. You looked up the count of datacenters used by a SSR framework and estimated that the network delays will be perceptible for users in the Moto G4/3G scenario.

Conclusion.<br/>
This perceptibility makes an SPA to be a clear winner, even without its ability to easily share state between internal SPA pages. You know that opinionated SSR frameworks allow a component to be exempted from prerendering. However you are already concerned about your code becoming unportable as a result of using a framework. The perspective of making the code even less portable by using additional framework-specific exemption constructs doesn’t look attractive.

### Case: SEO
SEO is extremely important for your project. The good news is that websites developed using Crisp React get indexed by Google, see the list of the websites in [README](https://github.com/winwiz1/crisp-react#when-to-use).

This solution adheres to Google [guidelines](https://developers.google.com/search/docs/advanced/javascript/javascript-seo-basics) which contributes to indexing. If both the full stack and Jamstack websites built and deployed automatically from GitHub repository are indexed, then there is no any inherent reason why your website, built using the same boilerplate, won't be indexed as well provided you follow the guidelines. No matter which build option (Jamstack or full stack) you choose.

Google has spent considerable effort on educating developers about [Structured Data](https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data) and made the online [Rich Results Test](https://search.google.com/test/rich-results) tool available. Again, this solution assists by helping to embed one or several pieces of such data (either static e.g. hardcoded or dynamic) into the `<head>` element of your website. The existing sample data can be used as a placeholder and replaced with your own data.

More details are available from the [SEO](https://github.com/winwiz1/crisp-react#seo) section.


### Case: Build complexity
You have considered the most widely used package to create a React app. Which you enjoyed while learning the framework. However the package is effectively managed by `react-scripts` that in the past used to be a standalone project with its own repository. For production deployments you prefer to have instead a simple and straightforward `scripts` section in the [`package.json`](https://github.com/winwiz1/crisp-react/blob/master/client/package.json) file with just a few one-line scripts. Even though you can eject the package, still the amount of code seems to be perfect for learning but is not to your liking for production. Your experience tells that resolving customer issues in the field would take time inversely proportional to complexity of the run-time code and building machinery.

You need to share your thoughts with colleagues and management. Getting some figures to backup your findings would help so you found a way to quantify the complexity: use the link `https://img.shields.io/github/languages/code-size/<user-name>/<repo-name>`. For Crisp React, you halved the reported figure since the client and the server subprojects each contribute ~50% of the codebase.

### Case: Build and run-time complexities
You have examined an opinionated framework for React apps build and deployment capable of run-time SSR. Even though you don’t need this functionality, you decided to give this option a consideration. It revealed significant run-time complexity which you quantified by the depth of the call stack that needs to be looked at while investigating a possible production issue. To be more specific, let’s investigate a simple hypothetical problem with browser’s requests for a React script bundle causing errors with the status code 404 Not Found.

* For Crisp React, you found the `node ./build/srv/main.js` command (that starts the backend) in the [`package.json`](https://github.com/winwiz1/crisp-react/blob/master/client/package.json) file. This lead you to the relevant source file and the [line of code](https://github.com/winwiz1/crisp-react/blob/master/server/src/srv/main.ts#L11). It increased the depth of the call stack from ‘0’ to ‘1’ while pointing to the code in [this](https://github.com/winwiz1/crisp-react/blob/master/server/src/srv/server.ts) file. You identified the [route handler](https://github.com/winwiz1/crisp-react/blob/master/server/src/srv/server.ts#L125) and when it gets executed, the call stack depth increases from ‘1’ to ‘2’. The handler is a thin wrapper around Express middleware. The middleware is called either directly, growing the call stack depth to '3', or indirectly via another helper function thus increasing the call stack depth to '4' at the point of time the Express middleware is executed.
    You assumed it's very unlikely that the issue at hand could be caused by either Express code or its stock middleware. Which restricted the scope of your troubleshooting effort to just 3 call stack levels with each level represented by a custom (e.g. non-Express) function.

* For the opinionated framework, you ran a CLI command to create a standalone project and found a simple command in the generated `package json` file that runs the server. However the command  doesn't call `node`, it  invokes the framework itself. You know that Express is used under the hood so you attempt to follow the call stack and find its depth at the point of time when the Express code or stock middleware is called.  The task could take quite a while (unless you put a breakpoint in Express code) and can be abandoned once it becomes clear the call stack is deeper than you are inclined to accept without the requirement to support run-time SSR.<br/> In other words, supporting run-time SSR is a complex task that requires complex code and the framework copes with this task very well. However, using the same complex machinery in cases when build-time SSR is sufficient results in an overkill.

Apart from maintainability/troubleshooting challenges, you know that on the one hand each call stack level (and the function it represents) usually expects some input data. On the other hand, maliciously crafting requests beyond of what is expected by the code on the receiving end is a known hacking technique. You appreciate that generally speaking, complexity doesn't help with security.
    
The opinionated SSR framework provides a managed cloud hosting that works well and scales well. It includes a CDN with a modest number of datacenters. You are aware of the possibility to chain this CDN with another CDN (that has more datacenters), however this option has a limited appeal to you for the same reason: you are a big fun of the KISS design principle.

### Case: Vendor lock-in
You work on a project and one of the key requirements is to avoid vendor lock-in. You shortlisted this solution because it doesn't require to consistently use any special programming constructs (including  component properties specific to Crisp React) throughout the code. You noted the SPA configuration file is solution-specific and so are the entrypoint files located under `src/entrypoints`. However the rest of the codebase is portable and so will be the code that you intend to write.

### Case: Simplicity
Your goal is a simple project with a straightforward client build coupled with no-hassle and free Jamstack deployment. At the end you would like to get a reasonably polished website (with good test scores) served to end users by the server provided by a Jamstack provider.

You used online tools (e.g. [web.dev/measure](https://web.dev/measure), [webpagetest.org](https://webpagetest.org)) to obtain the test scores for the website [jamstack.winwiz1.com](https://jamstack.winwiz1.com) which is deployed automatically from Jamstack builds. Then you went through the [Cloudflare Pages](https://github.com/winwiz1/crisp-react#cloudflare-pages) section to create your own site. You completed the section noting that it took around a minute to copy the configuration data provided in the section and paste it into the screen presented by Cloudflare. In response, Cloudflare had built and deployed the site. Finally you used the same online tools to get similar test scores for the newly built website.

### Case: Intellectual Property Protection
You work in an enterprise and need to protect Intellectual Property e.g. the business logic expressed in the React code. You'd like to have a separate Login SPA rendered by its own script bundle and make other bundles available for download to authenticated users only while parallelizing development among several teams. So that each team can work on one or several SPAs making it a unit of development, testing and acceptance by PM. You conclude this solution is easy to extend in order to achieve those goals. You plan to use this approach to add an additional layer to the existing RBAC (Role Based Access Security) e.g. make some bundles available depending on certain roles attested in the JWT token.

### Case: Security
The project you are engaged with requires top-notch security. You are focusing on Application Security and have implemented the whole battery of protective measures. That includes scrutinising the API requests before the actual processing can start. Various metrics are checked and the request size is on the list. You planned to use Jamstack build provided by this solution to create SRI compliant build artifacts, store those in a cloud bucket and let a CDN handle the requests. The API requests would be handled by API Gateway. The gateway would check the body of API requests and start cloud functions. The functions written in JS would also scrutinise the API requests by checking HTTP headers.

However SO (Security Officer) is not impressed. She points out that good security is always multilayered with repetitive/redundant measures duplicating each other. SO rules the restrictions on the request size and rate limiting must be additionally implemented at yet another layer along with some networking timeouts/limits. SO stipulates the code performing all those checks must be compiled rather than written in an interpreted language like JS.

> Backgrounder. The JS code is executed by the V8 engine. It compiles JS into CPU instructions at run-time further optimising the compiled code, again at run-time. The compilation is more or less predictable but the optimisation is not because in order to achieve the best performance it depends on run-time inputs. This lack of predictability due to non-deterministic code optimisation makes a comprehensive security audit of V8 impossible and results in vulnerabilities including zero day ones.

You comply with the additional security requirements by using Nginx. It's available as a Docker image. The API Gateway can start containers instead of functions so you switch from Jamstack build to full stack build that produces a Docker image. However the container management, including health monitoring, looms as a big issue. The API Gateway can monitor health provided the containers are modified to support a custom API used specifically for monitoring.

Now PM steps in and says you need to avoid vendor lock-in. That makes you consider Kubernetes. You conclude that k8s clusters, scaled to handle API requests from end users, will barely notice a much lighter workload of serving React app build artifacts to the CDN datacenters. You note this is exactly what the full stack build does - it uses a single server to combine the frontend and backend roles. Which makes the cloud bucket unnecessary and helps to improve maintenance by keeping the code responsible for HTTP headers management largely in one place. This architecture gets a nod from SO who is additionally pleased with security not being watered down by using CORS.

Back to the [README](https://github.com/winwiz1/crisp-react#when-to-use).
